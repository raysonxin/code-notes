# code-notes

类的生命周期：加载、连接（验证、准备、解析）、初始化、使用、销毁。
- 加载阶段三个过程：通过全限定名读取class文件（本地、网络、数据库等）、静态存储结构转换为方法区的运行时数据结构、生成代表这个类的Class对象（方法区）。
- 连接阶段：
    - 验证：文件格式验证（魔数、版本等）、元数据验证（是否有父类、字段定义是否合法）、字节码验证（控制流程、符号引用验证。
    - 准备：为类或接口的静态字段分配存储空间，并设置默认值。静态常量会直接赋值为用户指定的值。
    - 解析：把常量池内的符号引用转换为直接引用。
- 初始化阶段：按照用户的代码初始化变量，


JVM内存结构：
- 虚拟机栈：栈帧，每个栈帧内存储局部变量表、操作数栈、动态链接、方法出口等内容；
- 本地方法栈：运行native方法；
- 程序计数器
- 堆：新生代（Eden、F-S、T-S）、老年代。
- 方法区：元数据区。类型信息、大对象。

GC：标记-清除、标记-整理、复制。引用计数法、可达性算法（GC ROOTS）。局部变量表中的变量、静态变量引用、常量引用



利用Inoodb的undo log（回滚日志）是实现原子性的关键，当事物回滚时能够撤销所有已成功执行的sql语句，它需要记录你要回滚的相应日志信息undolog记录了这些回滚需要的信息当事物执行失败或调用了rollback就利用undolog中的日志信息将数据修改到回滚之前的样子。

利用Inoodb的redo log当数据在修改的时候不仅在内存中操作还会在redolog中记录这 次操作，当事物提交的时候会将redolog日志进行刷盘当数据库宕机重启的时候会将 redolog中的内容恢复到数据库中再根据undolog和binlog的内容决定回滚还是提交。

利用锁和mvcc机制，mvcc既多版本并发控制，如果一个事物读取的行正在做 delete/update操作，读取操作不会等行上的锁释放而是读取该行的快照版本。

数据库层面：数据库通过AID来保证了C，数据库必须要实现AID三大特性才能保证C。应用层面：通过代码判断数据库数据是否有效然后决定回滚还是提交事物操作
